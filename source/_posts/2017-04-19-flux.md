title: Flux
toc: false
date: 2017-04-19 17:04:09
tags: 
  - vuex
  - 状态管理
categories:
  - web前端
---

单一数据状态数据流管理
<!--more -->

# Flux
单一数据状态数据流管理

Flux将一个应用分成四个部分
- View： 视图层
- Action（动作）：视图层发出的消息（比如mouseClick）
- Dispatcher（派发器）：用来接收Actions、执行回调函数
- Store（数据层）：用来存放应用的状态，一旦发生变动，就提醒Views要更新页面
数据总是"单向流动"，任何相邻的部分都不会发生数据的"双向流动"。这保证了流程的清晰。

# Vuex
它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化

- State: 状态树: 包含所有应用级别状态的对象
- Action: 组件内部用来分发 mutation 事件的函数
- Mutation: 修改状态的事件回调函数（更改 Vuex 的 store 中的状态的唯一方法是提交 mutation）
- Getter: 在组件内部获取 store 中状态的函数（可以认为是 store 的计算属性）


- Module: Vuex 允许我们将 store 分割到模块（module）。每个模块拥有自己的 state、mutation、action、getters、甚至是嵌套子模块——从上至下进行类似的分割：
如果有些状态严格属于单个组件，最好还是作为组件的局部状态。你应该根据你的应用开发需要进行权衡和确定。则是对应组件内部的小树

![](flux/vue-flow.png)

![](vuex-complete.png)

>在 Vuex 中，mutation 都是同步事务：
Action 提交的是 mutation，而不是直接变更状态。
Action 可以包含任意异步操作。

# Vuex 并不限制你的代码结构。但是，它规定了一些需要遵守的规则：
- 应用层级的状态应该集中到单个 store 对象中。
- 提交 mutation 是更改状态的唯一方法，并且这个过程是同步的。
- 异步逻辑都应该封装到 action 里面。

# 是否应该使用状态管理吗

- 如果你的应用需要处理动态的数据，那很可能需要使用 Flux。如果只是一些静态的视图，它们之间不共享状态，你也没什么数据保存或者更新，就不需要使用 Flux，用了也没什么好处。
>关键：当 Store 变化时，View 无需关心条目是添加、删除，还是修改了。它只需要整个重绘，React 的 Virtual DOM diff 算法进行复杂的运算，找出哪些真实的 DOM 节点变化了。这可以帮助你简单生活，降低血压。


# 参考资料
- http://blog.andrewray.me/flux-for-stupid-people/

